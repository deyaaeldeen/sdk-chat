// Agent Client Protocol - .NET SDK
// Source generator for RPC method dispatch

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AgentClientProtocol.Sdk.Generators;

/// <summary>
/// Incremental source generator that creates compile-time RPC dispatch tables.
/// 
/// Scans interfaces marked with [RpcDispatcher] and methods marked with [RpcMethod]
/// to generate static dispatch dictionaries, eliminating runtime reflection and
/// switch statement maintenance.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class RpcDispatchGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the attribute source
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource("RpcAttributes.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Find all interfaces with [RpcDispatcher]
        var dispatcherInterfaces = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "AgentClientProtocol.Sdk.RpcDispatcherAttribute",
                predicate: static (node, _) => node is InterfaceDeclarationSyntax,
                transform: static (ctx, _) => GetDispatcherInfo(ctx))
            .Where(static info => info is not null)
            .Select(static (info, _) => info!);

        // Generate dispatch code
        context.RegisterSourceOutput(dispatcherInterfaces.Collect(), static (ctx, dispatchers) =>
        {
            if (dispatchers.IsDefaultOrEmpty) return;

            var source = GenerateDispatchExtensions(dispatchers);
            ctx.AddSource("RpcDispatch.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static DispatcherInfo? GetDispatcherInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol interfaceSymbol)
            return null;

        var attribute = context.Attributes.FirstOrDefault(a =>
            a.AttributeClass?.Name == "RpcDispatcherAttribute");

        if (attribute is null)
            return null;

        // Get the connection type from attribute
        var connectionType = attribute.ConstructorArguments.Length > 0
            ? attribute.ConstructorArguments[0].Value as string ?? "Client"
            : "Client";

        var methods = new List<RpcMethodInfo>();

        foreach (var member in interfaceSymbol.GetMembers())
        {
            if (member is not IMethodSymbol method) continue;

            var rpcAttr = method.GetAttributes().FirstOrDefault(a =>
                a.AttributeClass?.Name == "RpcMethodAttribute");

            if (rpcAttr is null) continue;

            var methodName = rpcAttr.ConstructorArguments.Length > 0
                ? rpcAttr.ConstructorArguments[0].Value as string
                : null;

            if (methodName is null) continue;

            var isNotification = rpcAttr.NamedArguments
                .FirstOrDefault(a => a.Key == "IsNotification")
                .Value.Value as bool? ?? false;

            // Get request and response types from method signature
            var requestType = method.Parameters.FirstOrDefault()?.Type.ToDisplayString();
            var responseType = method.ReturnType is INamedTypeSymbol returnType &&
                               returnType.IsGenericType &&
                               returnType.TypeArguments.Length > 0
                ? returnType.TypeArguments[0].ToDisplayString()
                : null;

            methods.Add(new RpcMethodInfo(
                methodName,
                method.Name,
                requestType ?? "object",
                responseType,
                isNotification));
        }

        return new DispatcherInfo(
            interfaceSymbol.Name,
            interfaceSymbol.ContainingNamespace.ToDisplayString(),
            connectionType,
            methods.ToImmutableArray());
    }

    private static string GenerateDispatchExtensions(ImmutableArray<DispatcherInfo> dispatchers)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();

        // Group dispatchers by namespace
        var byNamespace = dispatchers.GroupBy(d => d.Namespace);

        foreach (var nsGroup in byNamespace)
        {
            sb.AppendLine($"namespace {nsGroup.Key}");
            sb.AppendLine("{");

            foreach (var dispatcher in nsGroup)
            {
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// Generated RPC dispatch tables for {dispatcher.InterfaceName}.");
                sb.AppendLine($"    /// </summary>");
                sb.AppendLine($"    public static class {dispatcher.InterfaceName}Dispatch");
                sb.AppendLine("    {");

                // Generate request handlers dictionary
                var requestMethods = dispatcher.Methods.Where(m => !m.IsNotification).ToList();
                if (requestMethods.Count > 0)
                {
                    sb.AppendLine($"        /// <summary>");
                    sb.AppendLine($"        /// Creates the request dispatch table for {dispatcher.InterfaceName}.");
                    sb.AppendLine($"        /// O(1) lookup, generated at compile time.");
                    sb.AppendLine($"        /// </summary>");
                    sb.AppendLine($"        public static Dictionary<string, Func<{dispatcher.InterfaceName}, JsonElement?, Task<object?>>> CreateRequestHandlers()");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            return new Dictionary<string, Func<{dispatcher.InterfaceName}, JsonElement?, Task<object?>>>(StringComparer.Ordinal)");
                    sb.AppendLine("            {");

                    foreach (var method in requestMethods)
                    {
                        sb.AppendLine($"                [\"{method.MethodName}\"] = async (handler, json) => await handler.{method.HandlerMethodName}(Deserialize<{method.RequestTypeName}>(json)),");
                    }

                    sb.AppendLine("            };");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }

                // Generate notification handlers dictionary
                var notificationMethods = dispatcher.Methods.Where(m => m.IsNotification).ToList();
                if (notificationMethods.Count > 0)
                {
                    sb.AppendLine($"        /// <summary>");
                    sb.AppendLine($"        /// Creates the notification dispatch table for {dispatcher.InterfaceName}.");
                    sb.AppendLine($"        /// </summary>");
                    sb.AppendLine($"        public static Dictionary<string, Func<{dispatcher.InterfaceName}, JsonElement?, Task>> CreateNotificationHandlers()");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            return new Dictionary<string, Func<{dispatcher.InterfaceName}, JsonElement?, Task>>(StringComparer.Ordinal)");
                    sb.AppendLine("            {");

                    foreach (var method in notificationMethods)
                    {
                        sb.AppendLine($"                [\"{method.MethodName}\"] = async (handler, json) => await handler.{method.HandlerMethodName}(Deserialize<{method.RequestTypeName}>(json)),");
                    }

                    sb.AppendLine("            };");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }

                // Generate deserialize helper with AOT suppression
                sb.AppendLine("#pragma warning disable IL2026, IL3050 // Suppress AOT/trim warnings for JSON deserialization");
                sb.AppendLine("        private static T Deserialize<T>(JsonElement? element) =>");
                sb.AppendLine("            element.HasValue");
                sb.AppendLine("                ? element.Value.Deserialize<T>()!");
                sb.AppendLine("                : throw new InvalidOperationException(\"Missing parameters\");");
                sb.AppendLine("#pragma warning restore IL2026, IL3050");

                sb.AppendLine("    }");
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private const string AttributeSource = @"// <auto-generated/>
#nullable enable

namespace AgentClientProtocol.Sdk;

/// <summary>
/// Marks an interface as an RPC dispatcher for source generation.
/// The generator will create static dispatch tables for all [RpcMethod] methods.
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Interface, AllowMultiple = false)]
public sealed class RpcDispatcherAttribute : System.Attribute
{
    /// <summary>
    /// The type of connection (""Client"" or ""Agent"") for documentation.
    /// </summary>
    public string ConnectionType { get; }
    
    public RpcDispatcherAttribute(string connectionType = ""Client"")
    {
        ConnectionType = connectionType;
    }
}

/// <summary>
/// Marks a method as an RPC handler for source generation.
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple = false)]
public sealed class RpcMethodAttribute : System.Attribute
{
    /// <summary>
    /// The JSON-RPC method name (e.g., ""session/prompt"").
    /// </summary>
    public string MethodName { get; }
    
    /// <summary>
    /// True if this is a notification (no response expected).
    /// </summary>
    public bool IsNotification { get; set; }
    
    public RpcMethodAttribute(string methodName)
    {
        MethodName = methodName;
    }
}
";

    private sealed record DispatcherInfo(
        string InterfaceName,
        string Namespace,
        string ConnectionType,
        ImmutableArray<RpcMethodInfo> Methods);

    private sealed record RpcMethodInfo(
        string MethodName,
        string HandlerMethodName,
        string RequestTypeName,
        string? ResponseTypeName,
        bool IsNotification);
}
