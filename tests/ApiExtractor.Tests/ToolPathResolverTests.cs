// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using ApiExtractor.Contracts;
using Xunit;

namespace ApiExtractor.Tests;

/// <summary>
/// Tests for the ToolPathResolver secure path resolution utility.
/// These tests modify global state (environment variables and Console.Error),
/// so they must not run in parallel with other tests.
/// </summary>
[Collection("ToolPathResolver")]
public class ToolPathResolverTests
{
    #region ToolResolutionResult Record Tests

    [Fact]
    public void ToolResolutionResult_AvailableTool_HasCorrectProperties()
    {
        var result = new ToolResolutionResult(
            Path: "dotnet",
            AbsolutePath: "/usr/share/dotnet/dotnet",
            IsAvailable: true,
            WarningOrError: null
        );

        Assert.Equal("dotnet", result.Path);
        Assert.Equal("/usr/share/dotnet/dotnet", result.AbsolutePath);
        Assert.True(result.IsAvailable);
        Assert.Null(result.WarningOrError);
    }

    [Fact]
    public void ToolResolutionResult_UnavailableTool_HasErrorMessage()
    {
        var result = new ToolResolutionResult(
            Path: null,
            AbsolutePath: null,
            IsAvailable: false,
            WarningOrError: "tool not found"
        );

        Assert.Null(result.Path);
        Assert.Null(result.AbsolutePath);
        Assert.False(result.IsAvailable);
        Assert.Equal("tool not found", result.WarningOrError);
    }

    [Fact]
    public void ToolResolutionResult_WithSecurityWarning_ContainsPath()
    {
        var result = new ToolResolutionResult(
            Path: "suspicious",
            AbsolutePath: "/tmp/suspicious/bin/tool",
            IsAvailable: true,
            WarningOrError: "tool found at non-standard location: /tmp/suspicious/bin/tool"
        );

        Assert.True(result.IsAvailable);
        Assert.NotNull(result.WarningOrError);
        Assert.Contains("non-standard location", result.WarningOrError);
    }

    #endregion

    #region Resolve Method Tests

    [Fact]
    public void Resolve_FindsDotNet_WhenAvailable()
    {
        // dotnet is always available since we're running on it
        var result = ToolPathResolver.Resolve("dotnet", ["dotnet"]);

        Assert.NotNull(result);
        Assert.Equal("dotnet", result);
    }

    [Fact]
    public void Resolve_ReturnsNull_WhenToolNotFound()
    {
        var result = ToolPathResolver.Resolve(
            "nonexistent_tool_xyz_123",
            ["nonexistent_tool_xyz_123", "/path/to/nowhere/tool"]
        );

        Assert.Null(result);
    }

    [Fact]
    public void Resolve_TriesMultipleCandidates()
    {
        // First candidate doesn't exist, second (dotnet) does
        var result = ToolPathResolver.Resolve(
            "dotnet",
            ["nonexistent_first_candidate", "dotnet"]
        );

        Assert.NotNull(result);
        Assert.Equal("dotnet", result);
    }

    [Fact]
    public void Resolve_RespectsEnvironmentVariableOverride()
    {
        const string envVar = "SDK_CHAT_TESTENV_PATH";
        var originalValue = Environment.GetEnvironmentVariable(envVar);

        try
        {
            // Set environment variable to dotnet (which exists)
            Environment.SetEnvironmentVariable(envVar, "dotnet");

            var result = ToolPathResolver.Resolve(
                "testenv",
                ["nonexistent_candidate"],
                "--version"
            );

            // Should find dotnet via env var override
            Assert.Equal("dotnet", result);
        }
        finally
        {
            // Restore original value
            Environment.SetEnvironmentVariable(envVar, originalValue);
        }
    }

    [Fact]
    public void Resolve_FallsBackToDefaults_WhenEnvVarInvalid()
    {
        const string envVar = "SDK_CHAT_TESTFALLBACK_PATH";
        var originalValue = Environment.GetEnvironmentVariable(envVar);

        try
        {
            // Set environment variable to invalid path
            Environment.SetEnvironmentVariable(envVar, "/nonexistent/invalid/path");

            var result = ToolPathResolver.Resolve(
                "testfallback",
                ["dotnet"],  // Valid fallback
                "--version"
            );

            // Should fall back to dotnet
            Assert.Equal("dotnet", result);

            // Note: Resolve() no longer prints warnings - use ResolveWithDetails() for that
        }
        finally
        {
            Environment.SetEnvironmentVariable(envVar, originalValue);
        }
    }

    [Fact]
    public void ResolveWithDetails_ReturnsWarning_WhenEnvVarInvalid()
    {
        const string envVar = "SDK_CHAT_TESTFALLBACK2_PATH";
        var originalValue = Environment.GetEnvironmentVariable(envVar);

        try
        {
            // Set environment variable to invalid path
            Environment.SetEnvironmentVariable(envVar, "/nonexistent/invalid/path");

            var result = ToolPathResolver.ResolveWithDetails(
                "testfallback2",
                ["dotnet"],  // Valid fallback
                "--version"
            );

            // Should indicate not available due to invalid env var
            Assert.False(result.IsAvailable);
            Assert.NotNull(result.WarningOrError);
            Assert.Contains("SDK_CHAT_TESTFALLBACK2_PATH", result.WarningOrError);
            Assert.Contains("not a valid", result.WarningOrError);
        }
        finally
        {
            Environment.SetEnvironmentVariable(envVar, originalValue);
        }
    }

    [Fact]
    public void Resolve_UsesCustomVersionArgs()
    {
        // Test with "version" instead of "--version" (Go uses "go version")
        var result = ToolPathResolver.Resolve(
            "dotnet",
            ["dotnet"],
            "--version"  // dotnet uses --version
        );

        Assert.NotNull(result);
    }

    #endregion

    #region ResolveWithDetails Method Tests

    [Fact]
    public void ResolveWithDetails_ReturnsFullDetails_WhenToolFound()
    {
        var result = ToolPathResolver.ResolveWithDetails("dotnet", ["dotnet"]);

        Assert.True(result.IsAvailable);
        Assert.NotNull(result.Path);
        Assert.Equal("dotnet", result.Path);
        // AbsolutePath may or may not be set depending on 'which' availability
    }

    [Fact]
    public void ResolveWithDetails_ReturnsNotFound_WhenToolMissing()
    {
        var result = ToolPathResolver.ResolveWithDetails(
            "nonexistent_tool_abc",
            ["nonexistent_tool_abc"]
        );

        Assert.False(result.IsAvailable);
        Assert.Null(result.Path);
        Assert.NotNull(result.WarningOrError);
        Assert.Contains("not found", result.WarningOrError);
    }

    [Fact]
    public void ResolveWithDetails_IncludesAbsolutePath_WhenAvailable()
    {
        var result = ToolPathResolver.ResolveWithDetails("dotnet", ["dotnet"]);

        Assert.True(result.IsAvailable);
        // On most systems, which/where should resolve dotnet to an absolute path
        // But this may be null in some environments, so we just check it doesn't throw
    }

    #endregion

    #region Environment Variable Format Tests

    [Theory]
    [InlineData("python", "SDK_CHAT_PYTHON_PATH")]
    [InlineData("go", "SDK_CHAT_GO_PATH")]
    [InlineData("node", "SDK_CHAT_NODE_PATH")]
    [InlineData("jbang", "SDK_CHAT_JBANG_PATH")]
    [InlineData("MyTool", "SDK_CHAT_MYTOOL_PATH")]
    public void Resolve_UsesCorrectEnvVarFormat(string toolName, string expectedEnvVar)
    {
        // Verify the environment variable naming convention by setting a known value
        var originalValue = Environment.GetEnvironmentVariable(expectedEnvVar);

        try
        {
            // Set to a known valid executable
            Environment.SetEnvironmentVariable(expectedEnvVar, "dotnet");

            var result = ToolPathResolver.Resolve(toolName, ["nonexistent"]);

            // If env var is respected, it should find dotnet
            Assert.Equal("dotnet", result);
        }
        finally
        {
            Environment.SetEnvironmentVariable(expectedEnvVar, originalValue);
        }
    }

    #endregion

    #region Edge Cases

    [Fact]
    public void Resolve_HandlesEmptyCandidateArray()
    {
        var result = ToolPathResolver.Resolve("test", []);

        Assert.Null(result);
    }

    [Fact]
    public void Resolve_HandlesNullInCandidates()
    {
        // This should not throw, just skip null entries
        var result = ToolPathResolver.Resolve("dotnet", ["dotnet"]);

        Assert.NotNull(result);
    }

    [Fact]
    public void ResolveWithDetails_HandlesEmptyCandidateArray()
    {
        var result = ToolPathResolver.ResolveWithDetails("test", []);

        Assert.False(result.IsAvailable);
        Assert.Contains("not found", result.WarningOrError);
    }

    #endregion

    #region Integration Tests with Real Tools

    [Fact]
    public void Resolve_FindsPython_WhenAvailable()
    {
        // Python may or may not be installed, so we just verify no exception
        var result = ToolPathResolver.Resolve("python", ["python3", "python"]);

        // Result is either a valid path or null - both are acceptable
        if (result != null)
        {
            Assert.True(result == "python3" || result == "python");
        }
    }

    [Fact]
    public void Resolve_FindsNode_WhenAvailable()
    {
        var result = ToolPathResolver.Resolve("node", ["node"]);

        // Result is either a valid path or null - both are acceptable
        // Just verify no exception is thrown
    }

    [SkippableFact]
    public void ResolveWithDetails_DetectsSecurityWarning_ForNonStandardPath()
    {
        // This test verifies security warning logic
        // Skip if we can't create a test scenario

        var result = ToolPathResolver.ResolveWithDetails("dotnet", ["dotnet"]);

        Skip.IfNot(result.IsAvailable, "dotnet not available");
        Skip.If(result.AbsolutePath == null, "Could not resolve absolute path");

        // If dotnet is in a standard location, WarningOrError should be null
        // If in non-standard location, should contain warning
        // We can't control where dotnet is installed, so just verify the logic runs
    }

    #endregion
}
